vertfile``base2``
```glsl
/*
A fragment shader that visualizes the sine function in the complex plane.
It is expanded bit by bit from its Taylor series to generate an animation.
See https://en.wikipedia.org/wiki/Sine#Series_definition for more information.
*/
#version 450

#define PI (3.14159265359)
#define E (2.71828182846)

layout(location = 0) in vec2 inCoord;
layout(location = 0) out vec4 outColor;
layout(binding = 1) uniform UBO
{
	float time; // t from 1.0 to 11.0
	float random; // individual random value between 0.0 and 1.0 for each frame (unused)
} constants;

// product of two complex numbers
vec2 cmul(vec2 self, vec2 other) {
	return vec2(self.x * other.x - self.y * other.y,
				self.x * other.y + self.y * other.x);
}

// computes c^e / e!
vec2 cfpow(vec2 c, int e)
{
	vec2 r = vec2(1.0, 0.0);
	for(int i=1; i<=e; i++)
	{
		r = cmul(r, (c / float(i)));
	}
	return r;
}

// Taylor series expansion of sin(x) until from n=0 to n=steps-1
vec2 csin(const in vec2 x, const in int steps)
{
	vec2 res = vec2(0.0);
	for(int i=0; i<steps; i++)
	{
		res += (i%2==0?1:-1) * cfpow(x, 2*i+1);
	}
	return res;
}

// computes the color to visualize the complex value
vec3 color(vec2 y)
{
	vec3 c = vec3(atan(y.y, y.x) / (2*PI), 1.0, 1.0/log(length(y)+E));
	if(distance(y, vec2(0.0)) < 0.25)
	{
	  return vec3(1.0);
	}

	if(int(floor(y.x*10))%2 == 0 ^^ int(floor(y.y*10))%2 == 0)
	{
	  return vec3(0.0);
	}

	// HSV to RGB
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

void main()
{
	vec2 x = inCoord*pow(constants.time, 0.75)*2; // slowly zoom out
	vec2 y = csin(x, int(constants.time));

	outColor = vec4(color(y), 1.0);
}
```
animated 300 30 1.0 11.0 5M
